Isabelle Fite
February 8, 2025
CS-4373 High Performance Computing

# C-mini-challenges

1. a. For the Hello, NAME challenge, I used an argument from the command line because I wanted to learn how to work with command line arguments in C. b. Memory for the string is dynamically allocated since the length of the name isn't known at compile time. 

2. a. I timed my program with clock() from time.h. b. I didn't notice any issues with convergence, but looking at the output of clock, I'm at the limit of clock's precision. So for this short of a runtime, I will only be able to get one significant figure this way. 

3. a. I read in the file line by line, allocating static memory for 32 chars for each line. After determining the size of the matrix from the first line, I allocated memory statically for the exact size int matrix needed. When loading and accesing my matrix, I iterated through the elements in each row before moving to the next row. b. The only challenge in reading in the file was to learn how to handle and parse files in C. c. I didn't notice anything special about the actual computation. d. I used clock() for timing, like mini challenge 2. 

4. a. Since clock() does not have the necessary precision, I set up a for loop for each operation to time a large number of calculations, and then averaged the results. I used lrand48() to generate random numbers for the operations to act on. To account for the effects of loop overhead and random number generation, I calculated baseline times of running the loop and generating the random numbers without performing any operation, and then subtracted those from the results. b. Double multiplication ended up around 3 times faster than double division, although int multiplication was around the same speed as int division. The difference makes sense, as int division truncates its result. Sqrt() surprisingly was the fastest, at around 60% the time of multiplication, while sin() was the slowest at 200 times the time of multiplication.

5. Use the attached code snippets as a basis for comparing the performance of row-major vs. column major computations. One snippet uses a static allocation for the array, the other allocates the array dynamically. Do a little experimentation with each approach. Vary the size of the square array from 128 X 128 on up, doubling it in size each time. Chart your results. Is there a difference in performance or behavior between static and dynamic? Between row-major and column-major? In terms of the latter, valgrind has been installed on your Linux VM, and its cachegrind tool facility may help provide some insights. Do some OSINT research to learn about valgrind....

a. What did you observe about differences in program behavior in static vs dynamic allocation of arrays, and how do you explain it?

a. When trying to run the static code snippet making only the suggested changes, I got a seg fault from to initiallizing the matrix as 128x128 and trying to fill it with 256x256 values. Because the memory is not flexible, the static memory must be known or guessed ahead of time. After fixing that, I got another seg fault at 512x512. I believe this is due to static memory normally being allocated on the stack, which can't hold the 8x512x512 bytes = 2 GB that the array would need. b. As seen in the graph, the row-major code performs better. This makes sense as the CPU can read adjacent values in a row as a single cache line, while values in a column are spread out along cache lines. 

6. a. Instead of using pointer arithmetic, one could use just the indices of the character arrays. Relatedly, there are  a lot of possiblities for what the function passed as an argument could be doing. It could take an index, an input string index or an output string index and return the shuffled version of any of these as well. As written, the function returns a new string, but it would be interesting to modify the existing string after making a copy. b. The approach I took depends on the way the computer allocates memory, for instance assuming that the pointer to ith position in an array is given by i + pointer of the first position. This might not be true in all cases. In addition, it was difficult to keep track of all the pointers, which led to some errors. This will likely get better with practice, though.